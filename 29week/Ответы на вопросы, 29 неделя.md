# Ответы на вопросы, 29 неделя

1) Нет, так как пропсы изнутри компонента, в который они переданы, изменить нельзя (в примере - попытка изменить пропс title)

2) С помощью метода getDerivedStateFromProps(), если нужно передать новое значение пропса в состояние, или componentDidUpdate(), если нужно что-то сделать после изменения пропса и ререндера.

3) Первая запись делает ссылку, второй - независимую копию. Через ссылку изначальный объект будет мутировать при изменении нового объекта, с независимой копией такого происходить не будет.

4) componentDidMount() или useEffect(() ⇒ (//some code//), [])

5) componentDidCatch(), но он ловит ошибку не в себе, а в ребенке

6) 

```jsx
constructor(props) {
	super(props) //чтобы обратиться к родителю и унаследовать контекст (иначе this не будет работать)
	this.state {
		count: 0 //создаем состояние
	}
	this.function = this.function.bind(this) // привязка контекста к функции, иначе this не работает
}
```

7) render() отрисовывает переданный в нее jsx-код. Ее вызывает любое изменение состояния и пропса и изначальная отрисовка.

8)

```jsx
function Timer(props) {
	return(
	<p>Minutes: {props.minutes}</p>
	<p>Seconds: {props.seconds}</p>
	);
}

Timer.defaultProps = {
	minutes: 0,
	seconds: 0
}
```

9) Да, если он используется для разных методов жизненного цикла.

10) Тогда переданный в него код будет выполняться после изначальной отрисовки и каждого ре-рендера

11) componentWillUnmount()

12) Да, если они были изменены. Если нет, то React не увидит необходимости для переррисовки.