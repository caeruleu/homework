# Виртуальный DOM (VDOM)

**Что такое виртуальный DOM?**

Виртуальный DOM (VDOM) - легковесная копия реального DOM, которая хранится в памяти. Виртуальный и реальный DOM синхронизируются с помощью библиотеки React DOM.

VDOM - это Javascript-объект. Как и DOM, он является объектным представлением HTML-документа. Однако, поскольку он представляет собой объект, мы можем свободно и часто им манипулировать, не прикасаясь к DOM без крайней необходимости.

**Зачем нам VDOM, если есть реальный?**

Когда в 1998 году была выпущена первая спецификация для DOM, управление веб-страницами было другим - обновление элементов страницы использовалось гораздо реже чем сегодня. Из-за этой разницы проявилась особенность - DOM не расчитан для динамического интерфейса.

Это становится явным на больших сайтах, когда DOM-дерево разрастается до тысяч узлов (так в контексте DOM называются объекты). Так, перестроение тысячи дивов из трех столбцов в два (например, когда мы изменили размер окна до порогового значения) займет больше секунды. 

Почему? Сами по себе изменения и обновления DOM являются достаточно быстрыми. Но после изменения обновленный узел и все его потомки должны быть повторно отрисованы (отрендерены) для обновления UI приложения. А манипуляции с DOM осуществляются очень часто, и они намного медленнее большинства Javascript-операций.

**Как эту проблему решает VDOM?**

В React для каждого объекта реального DOM существует соответствующий объект VDOM. VDOM содержит те же свойства, что и DOM, но не может напрямую влиять на то, что отображается на экране. Именно потому, что манипуляции с VDOM не отрисовываются, они выполняются гораздо быстрее. Так как это простой объект Javascript, мы можем свободно и часто манипулировать им, не касаясь реального DOM, пока нам это не понадобится.

**Как работает VDOM?**

В React почти каждый компонент имеет состояние (state). При изменении состояния компонента, создается копия VDOM с внесенными изменениями. Далее происходит сравнение предыдущей версии VDOM и нынешней. После определения всех различий мы можем отправить их в DOM для выполнения необходимых обновлений. 

![Untitled](https://user-images.githubusercontent.com/84741982/146640438-23195122-150e-4533-87db-69c15b4ae1ee.png)

При сравнении двух деревьев, React начинает с корневых элементов. Дальнейшие операции зависят от типов этих элементов:

- Если корневые элементы имеют разные типы, React уничтожает старое дерево и строит новое с нуля.
- При сравнении двух элементов одинакового типа, React «смотрит» на атрибуты этих элементов. Узлы DOM сохраняются, изменяются только их атрибуты.

**Когда и VDOM может работать неэффективно?**

По умолчанию React перебирает два списка дочерних элементов DOM-узла и генерирует мутацию при обнаружении различий. Например, при добавлении элемента в конец списка дочерних элементов, преобразование одного дерева в другое работает хорошо:

```jsx
//прежняя версия
<ul>
 <li>первый</li>
 <li>второй</li>
</ul>

//нынешняя версия
<ul>
 <li>первый</li>
 <li>второй</li>
 <li>третий</li>
</ul>
```

React "видит", что в обоих деревьях имеются `<li>первый</li>` и `<li>второй</li>`, пропускает их и вставляет в конец `<li>третий</li>`.

Обычно, вставка элемента в начало списка плохо влияет на производительность. Например, преобразование одного дерева в другое в данном случае будет работать плохо:

```jsx
//прежняя версия
<ul>
 <li>первый</li>
 <li>второй</li>
</ul>

//нынешняя версия
<ul>
 <li>нулевой</li>
 <li>первый</li>
 <li>второй</li>
</ul>
```

React не сможет понять, что `<li>первый</li>` и `<li>второй</li>` остались прежними и мутирует каждый элемент.

**Как это исправить?**

Для решения данной проблемы React предоставляет проп key. Когда дочерние элементы имеют ключи, React использует их для сравнения потомков текущего и предыдущего узлов. Например, добавление ключей к элементам из последнего примера сделает преобразование деревьев намного более эффективным:

```jsx
//прежняя версия
<ul>
 <li key="1">первый</li>
 <li key="2">второй</li>
</ul>

//нынешняя версия
<ul>
 <li key="0">нулевой</li>
 <li key="1">первый</li>
 <li key="2">второй</li>
</ul>
```

Теперь React знает, что элемент с ключом 0 является новым, а элементы с ключами 1 и 2 старыми. На практике в качестве ключей, как правило, используются идентификаторы. В крайнем случае, в качестве ключей можно использовать индексы массива. Это работает хорошо только в том случае, если порядок элементов остается неизменным. Изменение порядка элементов будет медленным.
