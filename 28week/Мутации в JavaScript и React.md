# Мутации в JavaScript и React

### **Что такое мутация?**

**Мутация** - это изменение объекта без создания новой переменной и переприсваивания значения. Например так мутирует объект:

```jsx
let cat = {
	name: 'Вася',
	age: 5
};

cat.age = 6;
//или
cat.sex = 'male';
```

А так массив: 

```jsx
let arr = ['a', 'b', 'c'];

arr.push('d');

//другие методы, вызывающие мутации:
arr.fill()
arr.pop()
arr.shift()
arr.unshift()
arr.splice()
arr.reverse()
arr.sort()
arr.flat()
```

Объекты мутабельны, а вот примитивы - нет, так как нельзя изменить его структуру или добавить свойства и методы.

Не стоит путать запись в переменные и в свойства объектов новых значений с мутацией. Когда в переменную записывают новое значение, фактически, изменяют то, на что она указывает. При мутации же меняется сам объект. Ссылка на объект, записанная в переменную или константу, остаётся той же самой.

### **Почему мутации бывают проблемой?**

Если ваш код подвержен мутациям, это значит что что-то может совершенно неожиданно измениться или поломаться. Например, при указании ссылки:

```jsx
let cat1 = cat;
cat1.name = 'Фрося';
```

В результате поле name поменялось не только в `cat1`, но и в оригинальном `cat` тоже (так как объекты в JavaScript передаются по ссылке). Хотя такого поведения мы явно не хотели. И такую ошибку будет сложно найти.

Инициализация переменной через `const` ситуацию не улучшит - он защищает от изменения переменную, но не ее значение (то есть нельзя присвоить этой переменной другой объект, но можно изменить поля оригинального объекта).

### Всегда ли мутаций стоит избегать?

Нет, есть веская причина для мутации – это оптимизация производительности. Если приходится работать с огромным объемом данных, то создание нового объекта/массива каждый раз – довольно затратная операция. Но тогда следует сделать мутацию явной.

```jsx
// неявная мутация:
let cats = ['Фрося', 'Вася', 'Рыжуля'];
let atVet = cats.sort().map(cat => `${cat} у ветеринара`);

// явная мутация:
let cats = ['Фрося', 'Вася', 'Рыжуля'];
let sortedCats = cats.sort();
let atVet = sortedCats.map(cat => `${cat} у ветеринара`);
```

### А что с React?

React не любит мутации. Особенно мутации состояния. Документация по React гласит:

> Объект состояния не должен мутировать. Изменения должны проявляться в виде нового объекта на основе входных данных из `state` и `props`.
> 

> Никогда не мутируйте `this.state` напрямую, так как более поздний вызов `setState()` может перезаписать эту мутацию. Относитесь к `this.state` как к иммутабельному объекту.
> 

Почему все так строго? Перед рендерингом React сравнивает предыдущую и нынешнюю версию виртуального DOM, чтобы отрендерить только изменившиеся элементы. Мутации же усложняют отслеживание изменений.

### Как избежать мутаций?

Есть несколько способов:

- Использовать методы, которые не вызывают мутаций. Например, `arr.concat()` для добавления в массив , `arr.filter()`, `arr.slice()` для удаления из массива, `array.map()` для замены элементов массива.
- Использовать плагины - например [eslint-plugin-better-mutation](https://github.com/sloops77/eslint-plugin-better-mutation), который запрещает любые мутации, кроме локальных переменных внутри функций. Но он часто ломается.
- Для работы с объектами использовать функцию `Object.assign()`. Она позволяет объединить свойства нескольких объектов в новом объекте. Но стоит помнить что первый объект в списке аргументов при этом мутирует, поэтому принято указывать первым пустой объект - `Object.assign({}, obj1, obj2).` Этот метод можно использовать и создания независимой копии:  `obj2 = Object.assign({}, obj1)`
- Заморозка - использовать функцию `Object.freeze()`. Но она работает только на один уровень вглубь - то есть если значением одного из свойств является объект, заморозка на него не действует и он все равно может мутировать. Для решения этой проблемы используется библиотека [deep-freeze](https://github.com/substack/deep-freeze).
- Использовать специальные библиотеки. Например [Immutable.js](https://immutable-js.github.io/immutable-js/) - это самая распространенная библиотека для работы с иммутабельными данными. Она выдаёт ошибку при попытке изменения обработанного с её помощью объекта. Среди аналогов - [Seamless-Immutable](https://github.com/rtfeldman/seamless-immutable) (удобная и простая) и [Mori](https://github.com/swannodette/mori) (самая быстрая).