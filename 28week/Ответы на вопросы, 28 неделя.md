# Ответы на вопросы, 28 неделя

1) Пропс передается в компонент снаружи, стейт хранится внутри компонента; пропс не получится изменить изнутри компонента, стейт изменить можно; пропс можно изменить из родительского компонента, стейт нельзя.

2) свойство состояния arr инициализируется позже чем его вызов, нужно поднять setState:

```jsx
handleChange = () => {
		this.setState({
      arr: chechedArr,
    });
    const chechedArr = this.state.arr; // [1,2,3] 
		chechedArr.push(5); // [1,2,3,5] 
  };
```

3) да, можно

```jsx
const [highlighted, setHighlighted] = useState(false);
const [hovered, setHover] = useState(false);
let highlightedClass = ("highlighted");
let hoveredClass = ('hovered');

let handleHighlighted = () => {setHighlighted(!highlighted);}
let handleHover = () => {setHover(!hovered);}

return(
	<div className = {`rateCard ${highlighted && highlightedClass} ${hovered && hoveredClass}`} 
			 onClick = {handleHighlighted} onMouseOver={handleHover}>
```

4) Через обработчик события handleChange, в котором мы задаем условия, при которых функция `functionState` изменяет состояние.

5) true, так как функция this.setState была вызвана и поменяла стейт

6) 

```jsx
// 1) правильный
handleChange = () => {...};

// 2)
handleChange() {...};
```

7) Сейчас отличаются только синтаксисом, практически все старые преимущества классовых компонентов теперь есть и в функциональных. Единственное серьезное отличие - error boundaries (границы ошибки, аналог catch из JS) до сих пор пишутся только с помощью классовых компонентов. В остальных случаях редпочтительней функциональные.

8) В функциональных компонентах this нет, к состоянию можно получить доступ через функцию, которую мы создаем вместе с переменной состояния: `const [state, **functionState**]`

9) Да, можно, props и state независимы друг от друга.

10) В функциональном компоненте

11) В классовом компоненте переменная состояния всегда объект, в функциональном она может иметь любой тип

12) Нет, для этого раньше использовались классовые компоненты, а теперь хуки

13) Никак

14)

```jsx
//вариант 1:
const name = props.name || 'John'

//вариант 2 (предпочтительней):
static DefaultProps = {name: 'John'}
```
